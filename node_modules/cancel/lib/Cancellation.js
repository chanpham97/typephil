'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CancellationError = require('./CancellationError');

var _CancellationError2 = _interopRequireDefault(_CancellationError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var noop = function noop() {};

var Cancellation = function () {
  function Cancellation() {
    _classCallCheck(this, Cancellation);

    this.internalIsCanceled = false;
    this.listeners = [];
  }

  _createClass(Cancellation, [{
    key: 'isCanceled',


    /**
     * Returns `true` if cancellation has been requested; otherwise, returns `false`.
     */
    value: function isCanceled() {
      return this.internalIsCanceled;
    }

    /**
     * Issues a cancellation request.
     *
     * It is safe to call this method multiple times since all but the first call are ignored.
     */

  }, {
    key: 'cancel',
    value: function cancel() {
      // Return if cancellation has already been requested.
      if (this.internalIsCanceled) {
        return;
      }

      this.internalIsCanceled = true;

      // Notify and remove listeners
      this.listeners.forEach(function (listener) {
        return listener();
      });
      this.listeners = null;
    }

    /**
     * Throws a `CancellationError` if cancellation has been requested.
     */

  }, {
    key: 'throwIfCanceled',
    value: function throwIfCanceled() {
      if (this.internalIsCanceled) {
        throw new _CancellationError2.default('Operation has been canceled.');
      }
    }

    /**
     * Adds a listener to be notified when cancellation is requested.
     *
     * @param {Function} listener The function to be called when cancellation is requested.
     * @returns {Function} A function that, when called, removes the listener.
     */

  }, {
    key: 'onCancel',
    value: function onCancel(listener) {
      var _this = this;

      if (this.internalIsCanceled) {
        return noop;
      }

      this.listeners.push(listener);

      return function () {
        if (_this.listeners) {
          var index = _this.listeners.indexOf(listener);
          if (index !== -1) {
            _this.listeners.splice(index, 1);
          }
        }
      };
    }

    /**
     * Creates a child `Cancellation` object.
     *
     * @returns {Cancellation}
     */

  }, {
    key: 'fork',
    value: function fork() {
      if (this.internalIsCanceled) {
        return Cancellation.CANCELED;
      }

      var child = new Cancellation();
      this.onCancel(function () {
        return child.cancel();
      });
      return child;
    }
  }]);

  return Cancellation;
}();

/*
 * A `Cancellation` object that is already in the canceled state.
 */


exports.default = Cancellation;
Cancellation.CANCELED = new Cancellation();
Cancellation.CANCELED.internalIsCanceled = true;